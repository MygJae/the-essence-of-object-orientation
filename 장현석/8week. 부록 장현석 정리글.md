# 부록A. 추상화기법

## 추상화 종류

* 분류와 인스턴스화
* 일반화와 특수화
* 집합과 분해

<hr>

## 1. 분류와 인스턴스화

### * 개념과 범주

객체들의 특정집합에 공통의 개념을 적용하는 것    

* 바퀴를 이용해 사람들을 운반하는 운송수단 -> 자동차
* 푸른 잎과 갈색의 줄기를 가진 다년생 식물 -> 나무

분류는 세상에 존재하는 객체에 개념을 적용하는 과정이다.  
우리는 무수히 많은 자동차와 나무를 개별적으로 다루지않고 하나의 범주로 묶어 복잡성을 낮춘다.  

1. 분류를 통해 개별현상을 하나의 개념으로 다룬다.
2. 수많은 개별적인 현상들은 <code>객체</code>이다.
3. 하나의 개념은 <code>타입</code>이다.

객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 인스턴스라고 한다.
  
<br>

### * 타입

타입으로 객체를 분류할때 적용하는 세가지 관점
1. 심볼 : 간략한 이름이나 명칭
2. 내연 : 타입의 완전한 정의
3. 외연 : 타입에 속하는 모든 객체들의 집합

이걸 예전 챕터에선 심볼을 객체의 명칭, 내연은 객체의 책임, 외연은 인스턴스로 구분했던것 같다.  

<br>

### * 외연과 집합

p.234 수많은 컴퓨터들의 집합을 데스크톱, 사무용, 노트북 세가지로 분류하였다.  

이때 단일 분류와 다중 분류가 나온다.  
어떤 컴퓨터는 데스크톱 컴퓨터에 포함되면서 사무용 컴퓨터에 포함된다. 노트북도 마찬가지이다.  
하지만 객체지향 언어들은 단일 분류만을 지원한다. => 한 객체는 오직 한 클래스의 인스터스여야만 하며 동시의 두개의 클래스의 인스턴스일 수는 없다.  

또한 객체의 한 집합에서 다른 집합의 원소로 속하는 타입을 변경할 수 있는 경우 <code>동적 분류</code>라고 하고 변경할 수 없는 경우 <code>정적 분류</code>라고 한다.  

대부분의 객체지향 언어에선 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.  

작가의 경험으론 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정한다고 한다(...?)

대략적으로 복잡함을 줄이기 위해 단일 분류 + 정적 분류를 우선시하라는 말이다.

<br>

### * 클래스

클래스를 이용해 '타입을 구현하라'  
클래스는 타입을 구현하는 용도 외에도 여러가지로 사용되기에 클래스와 타입은 동일한 개념은 될 수 없다.  




<hr>
<br>

## 2. 일반화와 특수화

### * 범주의 계층
생물의 분류법의 기념비적인 논문인 '자연의 체계'에선 생물을 최상위 단계가 있는 중첩된 계층 구조로 나타내었다.  
일반적인 범주가 계층의 상위에 위치하고 세부적인 범주가 계층의 하위에 위치하는 방식이다.  
이때, 계층의 상위에 위치한 범주를 계층 하위에 위치한 범주의 <code>일반화</code>라고 하고 하위에 위치한 범주는 상위 범주의 <code>특수화</code>라고 한다.

<br>

### * 서브타입

조금 더 일반적인 타입이라면 슈퍼타입,  
좀 더 특수한 타입이라면 서브타입으로 계층구조를 구축할 수 있다.  
결국 서브타입은 슈퍼타입의 부분집합이고 본질적인 속성을 모두 포함하게 된다.  

<br>

### * 상속

프로그래밍 언어를 이용해 일반화, 특수화를 구현하는 것은 클래스 간의 상속을 사용하는 것이다.  
한 타입이 다른 타입의 서브타입이 되기 위해선 슈퍼타입에 순응해야 된다.  
순응에는 구조적인 순응, 행위적인 순응이 있다.  

구조적인 순응의 경우 슈퍼 타입의 어떤 속성을 가지고 있다면 서브 타입도 같은 속성을 가질 것이라고 생각되어 슈퍼타입을 대체할 수 있다.  
행위적인 순응은 '리스코프 치환 형식'으로 불리고 슈퍼타입이 getAge()라는 메시지를 받았고 나이를 반환한다면, 서브타입도 getAge()라는 메시지에서 나이를 반환해야한다.  
또한 하나의 클래스가 다른 클래스를 상속한다면 상속하는 타입은 부모 클래스의 데이터와 메서드를 사용하고 수정하고 확장할 수 있다.



<hr>
<br>

## 3. 집합과 분해

### * 합성관계
객체와 객체 사이의 전체-부분 관계를 구현하기 위해 합성관계를 사용한다.

합성관계를 통해 계층적인 객체들의 그룹을 만들게 되면  
-> 객체들의 그룹과 관련된 복잡성이 완화된다.  

물론 합성관계로 묶은 그룹들도 각자 다른 그룹과 관계가 미약하게나마 존재하지만 같은 그룹의 일부로써 존재할 수 없다.  
결국 그룹과 그룹간의 관계를 나타내는 물리적 통로가 존재하고 이를 연관관계라고 한다.  

<br>

### * 패키지

합성관계를 통해 객체 그룹을 단순화하여도 클래스 수가 많아지면 이것또한 관리하는 것이 매우 복잡해진다.  
이럴 경우 서로 관련성이 높은 클래스 집합을 논리적 단위로 통합해야 한다.  
이것을 '패키지' 또는 '모듈' 이라고 한다.  
패키지를 이용하면 전체적인 구조를 이해하기 위해 고려하는 요소의 수를 줄일 수 있다.  
또한 클래스의 집합을 캡슐화 함으로써 전체적인 복잡도를 낮출 수 있다.

<hr>
<br>

## 느낀점
* 예전에 엔티티를 유무형 혹은 발생시점에 따라 유형이니 개념이니 행위 엔터티니 구분하면서 외웠던 적이 있었다.. 도메인 설계만큼 관계형 db에서도 
각 엔티티간의 설계를 객체지향적으로 하기 위한 방법이 아니었나 싶다.

* 객체를 타입에 맞게 분류하여 집합으로 만들고 다른 집합과 연관관계를 어떻게 맺는가에 대해 설계단계에서 깊게 고민해봐야될것 같다.

* 책을 읽고 객체지향에 조금은. 더 다가가지 않았나 싶다.  
만약 이 책을 읽지 않았다면 객체에 대해서 전혀 다르게 알고있을것이다.  
특히, 인터페이스에 대해선 책을 통해 얻은 것이 아주 많은데 인터페이스를 막연히 상속과는 조금 결이 다른 + 객체간 상속이 아닌 행동의 구현 + 다중상속이 안되니 인터페이스로.. 요정도의 생각을 가지고 있었다.  
이 책을 읽고는 인터페이스를 캡슐화와 함께 생각해보고 도메인 설계의 관점에서도 생각해보고 명세의 관점, 객체간의 메시지 전달의 관점 등등  
내가 단순히 객체지향을 객체의 구현과 구현체로만 생각할게 아니란것을 배웠던 것 같다.